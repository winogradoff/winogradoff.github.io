<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post on Главная</title>
    <link>https://winogradoff.github.io/post/</link>
    <description>Recent content in Post on Главная</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-RU</language>
    <copyright>Иван Виноградов</copyright>
    <lastBuildDate>Thu, 03 Mar 2016 21:36:33 +0300</lastBuildDate>
    <atom:link href="https://winogradoff.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Обращение матрицы на Nvidia CUDA</title>
      <link>https://winogradoff.github.io/post/2016/03/03/gauss-jordan-inverse-matrix/</link>
      <pubDate>Thu, 03 Mar 2016 21:36:33 +0300</pubDate>
      
      <guid>https://winogradoff.github.io/post/2016/03/03/gauss-jordan-inverse-matrix/</guid>
      <description>

&lt;p&gt;Программирование графических процессоров на Nvidia CUDA. Начало.&lt;/p&gt;

&lt;p&gt;Первая лабораторная работа — нахождение обратной матрицы.
Для этого используется самый обычный &lt;a href=&#34;https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%93%D0%B0%D1%83%D1%81%D1%81%D0%B0_%E2%80%94_%D0%96%D0%BE%D1%80%D0%B4%D0%B0%D0%BD%D0%B0&#34;&gt;метод Гаусса-Жордана&lt;/a&gt;.
Он заключается в составлении расширенной матрицы. Справа к нашей матрице следует дописать единичную матрицу.&lt;/p&gt;

&lt;p&gt;Путем элементарных преобразований левая часть матрицы приводится к верхней треугольной.
Аналогичные преобразования проделываются в обратном ходе метода, обнуляя элементы над ведущим.
В итоге в правой части дополненной матрицы мы получим обратную матрицу.&lt;/p&gt;

&lt;h3 id=&#34;алгоритм-на-python:f386d8bd3c74b1c6b09568d7b0bbcc75&#34;&gt;Алгоритм на Python&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from copy import deepcopy
import sys


def words():
    &amp;quot;&amp;quot;&amp;quot;
    Чтение по словам
    &amp;quot;&amp;quot;&amp;quot;
    for line in sys.stdin:
        for word in line.split():
            yield word


def new_empty(n):
    &amp;quot;&amp;quot;&amp;quot;
    Создание новой матрицы
    &amp;quot;&amp;quot;&amp;quot;
    return [x[:] for x in [[0.0] * n] * n]


def pivotize(mat_a, x):
    &amp;quot;&amp;quot;&amp;quot;
    Путем обмена строк расположить наибольшие элементы на диагонали
    &amp;quot;&amp;quot;&amp;quot;
    mat_a = deepcopy(mat_a)
    size = len(mat_a)
    row = max(range(x, size), key=lambda i: abs(mat_a[i][x]))
    if x != row:
        mat_a[x], mat_a[row] = mat_a[row], mat_a[x]
    return mat_a


def invert(mat_a):
    &amp;quot;&amp;quot;&amp;quot;
    Обращение матрицы методом Гаусса-Жордана
    &amp;quot;&amp;quot;&amp;quot;
    mat_a = deepcopy(mat_a)
    n = len(mat_a)

    # Дополнить матрицу справа единичной матрицей
    for i in range(n):
        mat_a[i] += [int(i == j) for j in range(n)]

    # Прямой ход
    for x in range(n):
        mat_a = pivotize(mat_a, x)
        for i in range(x + 1, n):
            coefficient = mat_a[i][x] / mat_a[x][x]
            for j in range(x, n * 2):
                mat_a[i][j] -= coefficient * mat_a[x][j]

    # Обратный ход
    for x in reversed(range(n)):
        for i in reversed(range(x)):
            coefficient = mat_a[i][x] / mat_a[x][x]
            for j in reversed(range(n * 2)):
                mat_a[i][j] -= coefficient * mat_a[x][j]

    # Разделить строки на ведущие элементы
    for i in range(n):
        denominator = mat_a[i][i]
        for j in range(n * 2):
            mat_a[i][j] /= denominator

    # Оставить только правую часть матрицы
    for i in range(n):
        mat_a[i] = mat_a[i][n:]

    return mat_a


def main():
    w = words()
    n = int(next(w))
    mat_a = new_empty(n)
    for i in range(n):
        for j in range(n):
            mat_a[i][j] = float(next(w))

    result = invert(mat_a)
    for i in range(n):
        for j in range(n):
            print(&#39;{:.6e}&#39;.format(round(result[i][j], 10)), end=&#39; &#39;)
        print()


if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;а-теперь-на-c:f386d8bd3c74b1c6b09568d7b0bbcc75&#34;&gt;А теперь на C++&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;iomanip&amp;gt;
#include &amp;lt;cmath&amp;gt;

using namespace std;

void print(double *matrix, int n) {
  cout &amp;lt;&amp;lt; scientific;
  for (int i = 0; i &amp;lt; n; i++) {
    for (int j = 0; j &amp;lt; n; j++) {
      cout &amp;lt;&amp;lt; matrix[i * n + j] &amp;lt;&amp;lt; &amp;quot;\t&amp;quot;;
    }
    cout &amp;lt;&amp;lt; endl;
  }
}

// Обмен строк в матрице
void swap_lines(double *matrix, double *identity, int n, int i, int j) {
  double temp;
  for (int k = 0; k &amp;lt; n; k++) {
    temp = matrix[i * n + k];
    matrix[i * n + k] = matrix[j * n + k];
    matrix[j * n + k] = temp;

    temp = identity[i * n + k];
    identity[i * n + k] = identity[j * n + k];
    identity[j * n + k] = temp;
  }
}

// Поставить на место row строку с наибольшим ведущим коэффициентом
void pivotize(double *matrix, double *identity, int n, int row) {
  int max_index = row;
  double max_value = fabs(matrix[row * n + row]);
  double current_value;
  for (int i = row + 1; i &amp;lt; n; i++) {
    current_value = fabs(matrix[i * n + row]);
    if (current_value &amp;gt; max_value) {
      max_index = i;
      max_value = current_value;
    }
  }

  if (row != max_index) {
    swap_lines(matrix, identity, n, row, max_index);
  }
}

// Разделить строку матрицы на значение
void devide(double *matrix, int n, int i, double denominator) {
  for (int j = 0; j &amp;lt; n; j++) {
    matrix[i * n + j] /= denominator;
  }
}

// Обнуление элементов под ведущим элементом в строке x
void subtract_below(double *matrix, double *identity, int n, int x) {
  double coeff;
  for (int i = x + 1; i &amp;lt; n; i++) {
    coeff = matrix[i * n + x] / matrix[x * n + x];
    for (int j = x; j &amp;lt; n; j++) {
      matrix[i * n + j] -= coeff * matrix[x * n + j];
    }
    for (int j = 0; j &amp;lt; n; j++) {
      identity[i * n + j] -= coeff * identity[x * n + j];
    }
  }
}

// Обнуление элементов над ведущим элементом в строке x
void subtract_above(double *matrix, double *identity, int n, int x) {
  double coeff;
  for (int i = x - 1; i &amp;gt;= 0; i--) {
    coeff = matrix[i * n + x] / matrix[x * n + x];
    for (int j = x; j &amp;gt;= 0; j--) {
      matrix[i * n + j] -= coeff * matrix[x * n + j];
    }
    for (int j = 0; j &amp;lt; n; j++) {
      identity[i * n + j] -= coeff * identity[x * n + j];
    }
  }
}

// Обращение матрицы методом Гаусса-Жордана
void inverse(double *matrix, double *identity, int n) {
  // Прямой ход
  for (int i = 0; i &amp;lt; n - 1; i++) {
    // Обмен строк
    pivotize(matrix, identity, n, i);

    // Обнулить элементы ниже ведущего
    subtract_below(matrix, identity, n, i);
  }

  // Обратный ход
  for (int i = n - 1; i &amp;gt; 0; i--) {
    // Обнулить элементы выше ведущего
    subtract_above(matrix, identity, n, i);
  }

  // Разделить строки на ведущие элементы
  for (int i = 0; i &amp;lt; n; i++) {
    devide(identity, n, i, matrix[i * n + i]);
    devide(matrix, n, i, matrix[i * n + i]);
  }
}

int main() {
  int n;
  cin &amp;gt;&amp;gt; n;

  double *matrix = new double[n * n];
  double *identity = new double[n * n];

  for (int i = 0; i &amp;lt; n; i++) {
    for (int j = 0; j &amp;lt; n; j++) {
      cin &amp;gt;&amp;gt; matrix[i * n + j];
    }
  }

  for (int i = 0; i &amp;lt; n; i++) {
    for (int j = 0; j &amp;lt; n; j++) {
      identity[i * n + j] = i == j ? 1.0 : 0.0;
    }
  }

  inverse(matrix, identity, n);
  print(identity, n);

  delete[] matrix;
  delete[] identity;

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;что-нужно-для-написания-версии-под-cuda:f386d8bd3c74b1c6b09568d7b0bbcc75&#34;&gt;Что нужно для написания версии под CUDA?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Выделить независимые подпрограммы, которые можно распараллелить:

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;pivotize&lt;/strong&gt; — поиск масимального ведущего элемента и обмен строк,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;subtract_below&lt;/strong&gt; — обнуление элементов ниже ведущего,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;subtract_above&lt;/strong&gt; — обнуление элементов выше ведущего (обратный ход),&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;devide&lt;/strong&gt; — деление строк на их ведущие элементы.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Привести подпрограммы к выполнению однотипных действий:

&lt;ol&gt;
&lt;li&gt;функция &lt;strong&gt;pivotize&lt;/strong&gt; разделена на две:

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;max_in_column&lt;/em&gt; — поиск максимального ведущего элемента (индекс max_element_index сохраняется в глобальную память GPU)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;swap_lines&lt;/em&gt; — обмен строк (обмен текущей строки со строкой с индексом max_element_index)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;функция &lt;strong&gt;subtract_below&lt;/strong&gt; разделена на:

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;subtract_below&lt;/em&gt; — вычитание текущей строки из нижележащих строк правее ведущего столбца с целью обнулить элементы ниже ведущего&lt;/li&gt;
&lt;li&gt;&lt;em&gt;nullify_below&lt;/em&gt; — обнуление элементов в столбце под ведущим&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;функция &lt;strong&gt;subtract_above&lt;/strong&gt; разделена на:

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;subtract_above&lt;/em&gt; — вычитание текущей строки из вышележащих строк левее ведущего столбца с целью обнулить элементы выше ведущего&lt;/li&gt;
&lt;li&gt;&lt;em&gt;nullify_above&lt;/em&gt; — обнуление элементов в столбце над ведущим&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;функция &lt;strong&gt;devide&lt;/strong&gt; разделена на:

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;devide_identity&lt;/em&gt; — разделить строки правой матрицы на диагональные элементы левой матрицы&lt;/li&gt;
&lt;li&gt;&lt;em&gt;devide_matrix&lt;/em&gt; — заменить все диагональные элементы в левой матрице на единицы&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;итоговый-код-на-cuda:f386d8bd3c74b1c6b09568d7b0bbcc75&#34;&gt;Итоговый код на CUDA:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cmath&amp;gt;

#define DEBUG false
#define DEBUG_MATRIX false
#define DEBUG_TIMER true

using namespace std;

// Индекс строки с максимальным элементом из find_max_element_in_columnt()
__device__ int max_element_index;

void print(double* matrix, int n) {
  cout &amp;lt;&amp;lt; scientific;
  for (int i = 0; i &amp;lt; n; i++) {
    for (int j = 0; j &amp;lt; n; j++) {
      cout &amp;lt;&amp;lt; matrix[i * n + j] &amp;lt;&amp;lt; &amp;quot;\t&amp;quot;;
    }
    cout &amp;lt;&amp;lt; endl;
  }
}

void print_both(double* matrix, double* identity, int n) {
  cout &amp;lt;&amp;lt; scientific;
  for (int i = 0; i &amp;lt; n; i++) {
    for (int j = 0; j &amp;lt; 2 * n; j++) {
      if (j &amp;lt; n) {
        cout &amp;lt;&amp;lt; matrix[i * n + j] &amp;lt;&amp;lt; &amp;quot;\t&amp;quot;;
      } else {
        cout &amp;lt;&amp;lt; identity[i * n + j - n] &amp;lt;&amp;lt; &amp;quot;\t&amp;quot;;
      }
    }
    cout &amp;lt;&amp;lt; endl;
  }
}

// Обмен строк
__global__ void swap_lines(double* matrix, double* identity, int n, int row) {
  if (row == max_element_index) {
    return;
  }

  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  int offset = gridDim.x * blockDim.x;

  double temp;
  for (; idx &amp;lt; n; idx += offset) {
    temp = matrix[row * n + idx];
    matrix[row * n + idx] = matrix[max_element_index * n + idx];
    matrix[max_element_index * n + idx] = temp;

    temp = identity[row * n + idx];
    identity[row * n + idx] = identity[max_element_index * n + idx];
    identity[max_element_index * n + idx] = temp;
  }
}

// Сохранение индекса строки с максимальным элементом в max_element_index на GPU
__global__ void max_in_column(double* matrix, int n, int x) {
  int max_index = x;
  double max_value = fabs(matrix[x * n + x]);
  double current_value;

  for (int i = x + 1; i &amp;lt; n; i++) {
    current_value = fabs(matrix[i * n + x]);
    if (current_value &amp;gt; max_value) {
      max_index = i;
      max_value = current_value;
    }
  }

  max_element_index = max_index;
}

__global__ void devide_identity(double* matrix, double* identity, int n) {
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  int idy = blockIdx.y * blockDim.y + threadIdx.y;
  int offsetx = gridDim.x * blockDim.x;
  int offsety = gridDim.y * blockDim.y;

  for (int i = idx; i &amp;lt; n; i += offsetx) {
    for (int j = idy; j &amp;lt; n; j += offsety) {
      identity[i * n + j] /= matrix[i * n + i];
    }
  }
}

__global__ void devide_matrix(double* matrix, int n) {
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  int offsetx = gridDim.x * blockDim.x;
  for (int i = idx; i &amp;lt; n; i += offsetx) {
    matrix[i * n + i] = 1.0;
  }
}

// Обнуление элементов под ведущим элементом в строке x
__global__ void subtract_below(double* matrix, double* identity, int n, int x) {
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  int idy = blockIdx.y * blockDim.y + threadIdx.y;
  int offsetx = gridDim.x * blockDim.x;
  int offsety = gridDim.y * blockDim.y;

  int i, j;
  double coeff;
  for (i = x + 1 + idx; i &amp;lt; n; i += offsetx) {
    coeff = matrix[i * n + x] / matrix[x * n + x];
    for (j = x + 1 + idy; j &amp;lt; n; j += offsety) {
      matrix[i * n + j] -= coeff * matrix[x * n + j];
    }
    for (j = idy; j &amp;lt; n; j += offsety) {
      identity[i * n + j] -= coeff * identity[x * n + j];
    }
  }
}

__global__ void nullify_below(double* matrix, int n, int x) {
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  int offsetx = gridDim.x * blockDim.x;
  for (int i = x + 1 + idx; i &amp;lt; n; i += offsetx) {
    matrix[i * n + x] = 0.0;
  }
}

// Обнуление элементов над ведущим элементом в строке x
__global__ void subtract_above(double* matrix, double* identity, int n, int x) {
  int idx = threadIdx.x + blockIdx.x * blockDim.x;
  int idy = threadIdx.y + blockIdx.y * blockDim.y;
  int offsetx = gridDim.x * blockDim.x;
  int offsety = gridDim.y * blockDim.y;

  int i, j;
  double coeff;
  for (i = x - 1 - idx; i &amp;gt;= 0; i -= offsetx) {
    coeff = matrix[i * n + x] / matrix[x * n + x];
    for (j = x - 1 - idy; j &amp;gt;= 0; j -= offsety) {
      matrix[i * n + j] -= coeff * matrix[x * n + j];
    }
    for (j = idy; j &amp;lt; n; j += offsety) {
      identity[i * n + j] -= coeff * identity[x * n + j];
    }
  }
}

__global__ void nullify_above(double* matrix, int n, int x) {
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  int offsetx = gridDim.x * blockDim.x;
  for (int i = x - idx - 1; i &amp;gt;= 0; i -= offsetx) {
    matrix[i * n + x] = 0.0;
  }
}

// Обращение матрицы методом Гаусса-Жордана
void inverse_gpu(double* matrix, double* identity, int n) {
  dim3 BLOCKS_1D(16);
  dim3 THREADS_1D(32);
  dim3 BLOCKS_2D(16, 16);
  dim3 THREADS_2D(32, 32);

  double* dev_matrix;
  double* dev_identity;
  cudaMalloc(&amp;amp;dev_matrix, sizeof(double) * n * n);
  cudaMalloc(&amp;amp;dev_identity, sizeof(double) * n * n);
  cudaMemcpy(dev_matrix, matrix, sizeof(double) * n * n,
             cudaMemcpyHostToDevice);
  cudaMemcpy(dev_identity, identity, sizeof(double) * n * n,
             cudaMemcpyHostToDevice);

  cudaEvent_t start, stop;

  if (DEBUG &amp;amp;&amp;amp; DEBUG_TIMER) {
    cudaEventCreate(&amp;amp;start);
    cudaEventCreate(&amp;amp;stop);
    cudaEventRecord(start, 0);
  }

  // Прямой ход
  for (int i = 0; i &amp;lt; n; i++) {
    // Обменять строку со строкой с наибольшим ведущим элементом и обнулить
    // элементы под ним
    max_in_column&amp;lt;&amp;lt;&amp;lt;1, 1&amp;gt;&amp;gt;&amp;gt;(dev_matrix, n, i);
    swap_lines&amp;lt;&amp;lt;&amp;lt;BLOCKS_1D, THREADS_1D&amp;gt;&amp;gt;&amp;gt;(dev_matrix, dev_identity, n, i);
    subtract_below&amp;lt;&amp;lt;&amp;lt;BLOCKS_2D, THREADS_2D&amp;gt;&amp;gt;&amp;gt;(dev_matrix, dev_identity, n, i);
    nullify_below&amp;lt;&amp;lt;&amp;lt;BLOCKS_1D, THREADS_1D&amp;gt;&amp;gt;&amp;gt;(dev_matrix, n, i);
  }

  // Обратный ход
  for (int i = n - 1; i &amp;gt;= 0; i--) {
    // Обнулить элементы выше ведущего
    subtract_above&amp;lt;&amp;lt;&amp;lt;BLOCKS_2D, THREADS_2D&amp;gt;&amp;gt;&amp;gt;(dev_matrix, dev_identity, n, i);
    nullify_above&amp;lt;&amp;lt;&amp;lt;BLOCKS_1D, THREADS_1D&amp;gt;&amp;gt;&amp;gt;(dev_matrix, n, i);
  }

  // Разделить строки на их ведущие элементы
  devide_identity&amp;lt;&amp;lt;&amp;lt;BLOCKS_2D, THREADS_2D&amp;gt;&amp;gt;&amp;gt;(dev_matrix, dev_identity, n);
  devide_matrix&amp;lt;&amp;lt;&amp;lt;BLOCKS_1D, THREADS_1D&amp;gt;&amp;gt;&amp;gt;(dev_matrix, n);

  if (DEBUG &amp;amp;&amp;amp; DEBUG_TIMER) {
    cudaGetLastError();
    cudaEventRecord(stop, 0);
    cudaEventSynchronize(stop);
    float t;
    cudaEventElapsedTime(&amp;amp;t, start, stop);
    cout &amp;lt;&amp;lt; t &amp;lt;&amp;lt; endl;
    cudaEventDestroy(start);
    cudaEventDestroy(stop);
  }

  cudaMemcpy(matrix, dev_matrix, sizeof(double) * n * n,
             cudaMemcpyDeviceToHost);
  cudaMemcpy(identity, dev_identity, sizeof(double) * n * n,
             cudaMemcpyDeviceToHost);
  cudaFree(dev_matrix);
  cudaFree(dev_identity);
}

int main() {
  int n;
  cin &amp;gt;&amp;gt; n;

  double* matrix = new double[n * n];
  double* identity = new double[n * n];

  for (int i = 0; i &amp;lt; n; i++) {
    for (int j = 0; j &amp;lt; n; j++) {
      cin &amp;gt;&amp;gt; matrix[i * n + j];
    }
  }

  for (int i = 0; i &amp;lt; n; i++) {
    for (int j = 0; j &amp;lt; n; j++) {
      identity[i * n + j] = i == j ? 1.0 : 0.0;
    }
  }

  if (DEBUG &amp;amp;&amp;amp; DEBUG_MATRIX) {
    cout &amp;lt;&amp;lt; &amp;quot;Before:&amp;quot; &amp;lt;&amp;lt; endl;
    print_both(matrix, identity, n);
    cout &amp;lt;&amp;lt; endl;
  }

  inverse_gpu(matrix, identity, n);

  if (DEBUG &amp;amp;&amp;amp; DEBUG_MATRIX) {
    cout &amp;lt;&amp;lt; &amp;quot;After:&amp;quot; &amp;lt;&amp;lt; endl;
    print_both(matrix, identity, n);
    cout &amp;lt;&amp;lt; endl;
  }

  if (!DEBUG) {
    // Вывести обратную матрицу
    print(identity, n);
  }

  delete[] matrix;
  delete[] identity;

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Подход к параллельным вычислениям предлагаемый Nvidia довольно прост: давайте ускорим циклы с однотипными действиями.&lt;/p&gt;

&lt;p&gt;Стоит отметить, что &lt;strong&gt;основная сложность&lt;/strong&gt; при написании программ на CUDA — выделение тех частей алгоритма, которые можно распараллелить.&lt;/p&gt;

&lt;p&gt;Было бы очень интересно найти применение CUDA в реальном проекте.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Привет, GitHub!</title>
      <link>https://winogradoff.github.io/post/2016/02/22/hello/</link>
      <pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://winogradoff.github.io/post/2016/02/22/hello/</guid>
      <description>

&lt;p&gt;Решил я развернуть свой блог на новом движке &lt;a href=&#34;https://gohugo.io/&#34; title=&#34;Что за Hugo?&#34; target=&#34;_blank&#34;&gt;Hugo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Создатель Hugo обещает, что мы создадим сайт &lt;a href=&#34;https://gohugo.io/overview/quickstart/&#34;&gt;за 2 минуты&lt;/a&gt;, что являтся большим плюсом для новичков.&lt;/p&gt;

&lt;p&gt;Надо сказать, что многие &lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;темы&lt;/a&gt; используют какую-то странную структуру html-шаблонов, которая часто несогласована с &lt;a href=&#34;https://gohugo.io/templates/overview/&#34;&gt;документацией&lt;/a&gt;, но это довольно просто исправляется.&lt;/p&gt;

&lt;p&gt;Для себя я выбрал тему &lt;a href=&#34;https://github.com/jbub/ghostwriter&#34;&gt;Ghostwriter&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;что-я-менял-в-теме:8a07c3dae13f18d0c06cf5f9e482b173&#34;&gt;Что я менял в теме:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;изменил структуру шаблонов&lt;/li&gt;
&lt;li&gt;изменил формат вывода дат&lt;/li&gt;
&lt;li&gt;добавил иконку ВКонтакте в шапку сайта (иконки — символы шрифта &lt;a href=&#34;https://fortawesome.github.io/Font-Awesome/&#34; title=&#34;&#34; target=&#34;_blank&#34;&gt;Font Awesome&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;убрал подвал сайта (мне кажется он лишним)&lt;/li&gt;
&lt;li&gt;отключил Disqus (систему комментариев) и Google Analytics.&lt;/li&gt;
&lt;li&gt;подключил &lt;a href=&#34;https://vk.com/dev/Comments&#34; title=&#34;&#34; target=&#34;_blank&#34;&gt;виджет для комментариев ВКонтакте&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Пока это всё. Планирую постить сюда какие-то находки и соображения по своим проектам.
В ближайших планах заполнить страницу &lt;a href=&#34;https://winogradoff.github.io/page/about/&#34;&gt;Об авторе&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>